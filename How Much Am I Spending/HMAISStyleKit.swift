//
//  HMAISStyleKit.swift
//  How Much Am I Spending
//
//  Created by Shayne Torres on 11/9/16.
//  Copyright Â© 2016 sptorres. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class HMAISStyleKit : NSObject {

    //// Cache

    private struct Cache {
        static let mainOrangeColor: UIColor = UIColor(red: 1.000, green: 0.518, blue: 0.118, alpha: 1.000)
    }

    //// Colors

    public dynamic class var mainOrangeColor: UIColor { return Cache.mainOrangeColor }

    //// Drawing Methods

    public dynamic class func drawOrangeShoppingListButton(frame: CGRect = CGRect(x: 0, y: 0, width: 86, height: 85), isPressed: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let orangeOverlay = UIColor(red: 0.780, green: 0.404, blue: 0.090, alpha: 0.397)


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.03488 + 0.5), y: frame.minY + fastFloor(frame.height * 0.02353 + 0.5), width: fastFloor(frame.width * 0.96512 + 0.5) - fastFloor(frame.width * 0.03488 + 0.5), height: fastFloor(frame.height * 0.96471 + 0.5) - fastFloor(frame.height * 0.02353 + 0.5))


        //// Group 2
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
        HMAISStyleKit.mainOrangeColor.setFill()
        ovalPath.fill()


        //// Group
        //// Group 3
        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: group2.minX + fastFloor(group2.width * 0.19375) + 0.5, y: group2.minY + fastFloor(group2.height * 0.13125) + 0.5, width: fastFloor(group2.width * 0.80625) - fastFloor(group2.width * 0.19375), height: fastFloor(group2.height * 0.86875) - fastFloor(group2.height * 0.13125)))
        UIColor.white.setFill()
        rectangle4Path.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.26250 + 0.5), y: group2.minY + fastFloor(group2.height * 0.45000 + 0.5), width: fastFloor(group2.width * 0.73750 + 0.5) - fastFloor(group2.width * 0.26250 + 0.5), height: fastFloor(group2.height * 0.55000 + 0.5) - fastFloor(group2.height * 0.45000 + 0.5)), cornerRadius: 4)
        HMAISStyleKit.mainOrangeColor.setFill()
        rectangle2Path.fill()


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.26250 + 0.5), y: group2.minY + fastFloor(group2.height * 0.20000 + 0.5), width: fastFloor(group2.width * 0.73750 + 0.5) - fastFloor(group2.width * 0.26250 + 0.5), height: fastFloor(group2.height * 0.30000 + 0.5) - fastFloor(group2.height * 0.20000 + 0.5)), cornerRadius: 4)
        HMAISStyleKit.mainOrangeColor.setFill()
        rectanglePath.fill()


        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.26250 + 0.5), y: group2.minY + fastFloor(group2.height * 0.70000 + 0.5), width: fastFloor(group2.width * 0.73750 + 0.5) - fastFloor(group2.width * 0.26250 + 0.5), height: fastFloor(group2.height * 0.80000 + 0.5) - fastFloor(group2.height * 0.70000 + 0.5)), cornerRadius: 4)
        HMAISStyleKit.mainOrangeColor.setFill()
        rectangle3Path.fill()




        if (isPressed) {
            //// overlay Drawing
            let overlayPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
            orangeOverlay.setFill()
            overlayPath.fill()
        }
    }

    public dynamic class func drawOrangeMenuButton(frame: CGRect = CGRect(x: 0, y: 0, width: 86, height: 85), isPressed: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let orangeOverlay = UIColor(red: 0.780, green: 0.404, blue: 0.090, alpha: 0.397)


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.03488 + 0.5), y: frame.minY + fastFloor(frame.height * 0.02353 + 0.5), width: fastFloor(frame.width * 0.96512 + 0.5) - fastFloor(frame.width * 0.03488 + 0.5), height: fastFloor(frame.height * 0.96471 + 0.5) - fastFloor(frame.height * 0.02353 + 0.5))


        //// Group 2
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
        HMAISStyleKit.mainOrangeColor.setFill()
        ovalPath.fill()


        //// Group
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.25000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.43750 + 0.5), width: fastFloor(group2.width * 0.75000 + 0.5) - fastFloor(group2.width * 0.25000 + 0.5), height: fastFloor(group2.height * 0.56250 + 0.5) - fastFloor(group2.height * 0.43750 + 0.5)), cornerRadius: 5)
        UIColor.white.setFill()
        rectangle2Path.fill()


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.25000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.18750 + 0.5), width: fastFloor(group2.width * 0.75000 + 0.5) - fastFloor(group2.width * 0.25000 + 0.5), height: fastFloor(group2.height * 0.31250 + 0.5) - fastFloor(group2.height * 0.18750 + 0.5)), cornerRadius: 5)
        UIColor.white.setFill()
        rectanglePath.fill()


        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.25000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.68750 + 0.5), width: fastFloor(group2.width * 0.75000 + 0.5) - fastFloor(group2.width * 0.25000 + 0.5), height: fastFloor(group2.height * 0.81250 + 0.5) - fastFloor(group2.height * 0.68750 + 0.5)), cornerRadius: 5)
        UIColor.white.setFill()
        rectangle3Path.fill()




        if (isPressed) {
            //// overlay Drawing
            let overlayPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
            orangeOverlay.setFill()
            overlayPath.fill()
        }
    }

    public dynamic class func drawOrangeAddButton(frame: CGRect = CGRect(x: 0, y: 0, width: 86, height: 85), isPressed: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let orangeOverlay = UIColor(red: 0.780, green: 0.404, blue: 0.090, alpha: 0.397)


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.03488 + 0.5), y: frame.minY + fastFloor(frame.height * 0.02353 + 0.5), width: fastFloor(frame.width * 0.96512 + 0.5) - fastFloor(frame.width * 0.03488 + 0.5), height: fastFloor(frame.height * 0.96471 + 0.5) - fastFloor(frame.height * 0.02353 + 0.5))


        //// Group 2
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
        HMAISStyleKit.mainOrangeColor.setFill()
        ovalPath.fill()


        if (isPressed) {
            //// overlay Drawing
            let overlayPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
            orangeOverlay.setFill()
            overlayPath.fill()
        }


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.55782 * group2.width, y: group2.minY + 0.16330 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.21937 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.17810 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.19186 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.43750 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.21937 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.32457 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.70963 * group2.width, y: group2.minY + 0.43750 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.82180 * group2.width, y: group2.minY + 0.44159 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.79564 * group2.width, y: group2.minY + 0.43750 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.80940 * group2.width, y: group2.minY + 0.43750 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.82420 * group2.width, y: group2.minY + 0.44218 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.86250 * group2.width, y: group2.minY + 0.49688 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.84720 * group2.width, y: group2.minY + 0.45055 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.86250 * group2.width, y: group2.minY + 0.47241 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.86250 * group2.width, y: group2.minY + 0.50000 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.86250 * group2.width, y: group2.minY + 0.50000 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.86250 * group2.width, y: group2.minY + 0.50000 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.86250 * group2.width, y: group2.minY + 0.50312 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.82420 * group2.width, y: group2.minY + 0.55782 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.86250 * group2.width, y: group2.minY + 0.52759 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.84720 * group2.width, y: group2.minY + 0.54945 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.76813 * group2.width, y: group2.minY + 0.56250 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.80940 * group2.width, y: group2.minY + 0.56250 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.79564 * group2.width, y: group2.minY + 0.56250 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.56250 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.70963 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.64491 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.70963 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.55841 * group2.width, y: group2.minY + 0.82180 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.79564 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.56250 * group2.width, y: group2.minY + 0.80940 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.55782 * group2.width, y: group2.minY + 0.82420 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.50312 * group2.width, y: group2.minY + 0.86250 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.54945 * group2.width, y: group2.minY + 0.84720 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.52759 * group2.width, y: group2.minY + 0.86250 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.86250 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.86250 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.86250 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.49687 * group2.width, y: group2.minY + 0.86250 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.44218 * group2.width, y: group2.minY + 0.82420 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.47241 * group2.width, y: group2.minY + 0.86250 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.45055 * group2.width, y: group2.minY + 0.84720 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.43752 * group2.width, y: group2.minY + 0.78049 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.43826 * group2.width, y: group2.minY + 0.81180 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.43762 * group2.width, y: group2.minY + 0.80013 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.76813 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.77669 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.77259 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.70963 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.56250 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.66983 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.61724 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.29037 * group2.width, y: group2.minY + 0.56250 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.17820 * group2.width, y: group2.minY + 0.55841 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.20436 * group2.width, y: group2.minY + 0.56250 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.19060 * group2.width, y: group2.minY + 0.56250 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.17580 * group2.width, y: group2.minY + 0.55782 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.13750 * group2.width, y: group2.minY + 0.50312 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.15280 * group2.width, y: group2.minY + 0.54945 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.13750 * group2.width, y: group2.minY + 0.52759 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.13750 * group2.width, y: group2.minY + 0.50000 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.13750 * group2.width, y: group2.minY + 0.50000 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.13750 * group2.width, y: group2.minY + 0.50000 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.13750 * group2.width, y: group2.minY + 0.49687 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.17580 * group2.width, y: group2.minY + 0.44218 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.13750 * group2.width, y: group2.minY + 0.47241 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.15280 * group2.width, y: group2.minY + 0.45055 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.21951 * group2.width, y: group2.minY + 0.43752 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.18820 * group2.width, y: group2.minY + 0.43826 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.19987 * group2.width, y: group2.minY + 0.43762 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.23187 * group2.width, y: group2.minY + 0.43750 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.22331 * group2.width, y: group2.minY + 0.43750 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.22741 * group2.width, y: group2.minY + 0.43750 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.43750 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.27787 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.34887 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.27787 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.44159 * group2.width, y: group2.minY + 0.16570 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.19186 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.43750 * group2.width, y: group2.minY + 0.17810 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.44218 * group2.width, y: group2.minY + 0.16330 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.49688 * group2.width, y: group2.minY + 0.12500 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.45055 * group2.width, y: group2.minY + 0.14030 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.47241 * group2.width, y: group2.minY + 0.12500 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.12500 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.12500 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.12500 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.50312 * group2.width, y: group2.minY + 0.12500 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.55782 * group2.width, y: group2.minY + 0.16330 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.52759 * group2.width, y: group2.minY + 0.12500 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.54945 * group2.width, y: group2.minY + 0.14030 * group2.height))
        bezierPath.close()
        UIColor.white.setFill()
        bezierPath.fill()


        if (isPressed) {
            //// overlay 2 Drawing
            let overlay2Path = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
            orangeOverlay.setFill()
            overlay2Path.fill()
        }
    }

    public dynamic class func drawOrangeAddListButton(frame: CGRect = CGRect(x: 0, y: 0, width: 86, height: 85), isPressed: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let orangeOverlay = UIColor(red: 0.780, green: 0.404, blue: 0.090, alpha: 0.397)


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.03488 + 0.5), y: frame.minY + fastFloor(frame.height * 0.02353 + 0.5), width: fastFloor(frame.width * 0.96512 + 0.5) - fastFloor(frame.width * 0.03488 + 0.5), height: fastFloor(frame.height * 0.96471 + 0.5) - fastFloor(frame.height * 0.02353 + 0.5))


        //// Group 2
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
        HMAISStyleKit.mainOrangeColor.setFill()
        ovalPath.fill()


        if (isPressed) {
            //// overlay Drawing
            let overlayPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
            orangeOverlay.setFill()
            overlayPath.fill()
        }


        //// Group 3
        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: group2.minX + fastFloor(group2.width * 0.45625) + 0.5, y: group2.minY + fastFloor(group2.height * 0.15625) + 0.5, width: fastFloor(group2.width * 0.79375) - fastFloor(group2.width * 0.45625), height: fastFloor(group2.height * 0.56875) - fastFloor(group2.height * 0.15625)))
        UIColor.white.setFill()
        rectangle4Path.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.50000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.33750 + 0.5), width: fastFloor(group2.width * 0.75000 + 0.5) - fastFloor(group2.width * 0.50000 + 0.5), height: fastFloor(group2.height * 0.38750 + 0.5) - fastFloor(group2.height * 0.33750 + 0.5)), cornerRadius: 2)
        HMAISStyleKit.mainOrangeColor.setFill()
        rectangle2Path.fill()


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.50000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.20000 + 0.5), width: fastFloor(group2.width * 0.75000 + 0.5) - fastFloor(group2.width * 0.50000 + 0.5), height: fastFloor(group2.height * 0.25000 + 0.5) - fastFloor(group2.height * 0.20000 + 0.5)), cornerRadius: 2)
        HMAISStyleKit.mainOrangeColor.setFill()
        rectanglePath.fill()


        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.50000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.48750 + 0.5), width: fastFloor(group2.width * 0.75000 + 0.5) - fastFloor(group2.width * 0.50000 + 0.5), height: fastFloor(group2.height * 0.52500 + 0.5) - fastFloor(group2.height * 0.48750 + 0.5)), cornerRadius: 1.5)
        HMAISStyleKit.mainOrangeColor.setFill()
        rectangle3Path.fill()




        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.42465 * group2.width, y: group2.minY + 0.50827 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.53868 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.51630 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.52376 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.65699 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.53868 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.59574 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.50580 * group2.width, y: group2.minY + 0.65699 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.56575 * group2.width, y: group2.minY + 0.65921 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.55177 * group2.width, y: group2.minY + 0.65699 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.55912 * group2.width, y: group2.minY + 0.65699 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.56703 * group2.width, y: group2.minY + 0.65953 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.58750 * group2.width, y: group2.minY + 0.68919 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.57932 * group2.width, y: group2.minY + 0.66407 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.58750 * group2.width, y: group2.minY + 0.67592 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.58750 * group2.width, y: group2.minY + 0.69089 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.58750 * group2.width, y: group2.minY + 0.69089 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.58750 * group2.width, y: group2.minY + 0.69089 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.58750 * group2.width, y: group2.minY + 0.69258 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.56703 * group2.width, y: group2.minY + 0.72225 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.58750 * group2.width, y: group2.minY + 0.70586 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.57932 * group2.width, y: group2.minY + 0.71771 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.53706 * group2.width, y: group2.minY + 0.72479 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.55912 * group2.width, y: group2.minY + 0.72479 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.55177 * group2.width, y: group2.minY + 0.72479 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.72479 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.80459 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.76949 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.80459 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.42497 * group2.width, y: group2.minY + 0.86543 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.85124 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.42716 * group2.width, y: group2.minY + 0.85870 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.42465 * group2.width, y: group2.minY + 0.86673 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.39542 * group2.width, y: group2.minY + 0.88750 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.42018 * group2.width, y: group2.minY + 0.87920 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.40850 * group2.width, y: group2.minY + 0.88750 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.39375 * group2.width, y: group2.minY + 0.88750 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.39375 * group2.width, y: group2.minY + 0.88750 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.39375 * group2.width, y: group2.minY + 0.88750 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.39208 * group2.width, y: group2.minY + 0.88750 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.36285 * group2.width, y: group2.minY + 0.86673 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.37900 * group2.width, y: group2.minY + 0.88750 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.36732 * group2.width, y: group2.minY + 0.87920 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.36036 * group2.width, y: group2.minY + 0.84302 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.36075 * group2.width, y: group2.minY + 0.86000 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.36041 * group2.width, y: group2.minY + 0.85367 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.83632 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.84096 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.83873 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.80459 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.72479 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.78300 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.75448 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.28170 * group2.width, y: group2.minY + 0.72479 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.22175 * group2.width, y: group2.minY + 0.72257 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.23573 * group2.width, y: group2.minY + 0.72479 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.22838 * group2.width, y: group2.minY + 0.72479 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.22047 * group2.width, y: group2.minY + 0.72225 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.20000 * group2.width, y: group2.minY + 0.69258 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.20818 * group2.width, y: group2.minY + 0.71771 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.20000 * group2.width, y: group2.minY + 0.70586 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.20000 * group2.width, y: group2.minY + 0.69089 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.20000 * group2.width, y: group2.minY + 0.69089 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.20000 * group2.width, y: group2.minY + 0.69089 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.20000 * group2.width, y: group2.minY + 0.68919 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.22047 * group2.width, y: group2.minY + 0.65953 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.20000 * group2.width, y: group2.minY + 0.67592 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.20818 * group2.width, y: group2.minY + 0.66407 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.24383 * group2.width, y: group2.minY + 0.65700 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.22710 * group2.width, y: group2.minY + 0.65740 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.23334 * group2.width, y: group2.minY + 0.65706 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.25044 * group2.width, y: group2.minY + 0.65699 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.24587 * group2.width, y: group2.minY + 0.65699 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.24806 * group2.width, y: group2.minY + 0.65699 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.65699 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.57041 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.60892 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.57041 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.36253 * group2.width, y: group2.minY + 0.50957 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.52376 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.36034 * group2.width, y: group2.minY + 0.51630 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.36285 * group2.width, y: group2.minY + 0.50827 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.39208 * group2.width, y: group2.minY + 0.48750 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.36732 * group2.width, y: group2.minY + 0.49580 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.37900 * group2.width, y: group2.minY + 0.48750 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.39375 * group2.width, y: group2.minY + 0.48750 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.39375 * group2.width, y: group2.minY + 0.48750 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.39375 * group2.width, y: group2.minY + 0.48750 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.39542 * group2.width, y: group2.minY + 0.48750 * group2.height))
        bezierPath.addCurve(to: CGPoint(x: group2.minX + 0.42465 * group2.width, y: group2.minY + 0.50827 * group2.height), controlPoint1: CGPoint(x: group2.minX + 0.40850 * group2.width, y: group2.minY + 0.48750 * group2.height), controlPoint2: CGPoint(x: group2.minX + 0.42018 * group2.width, y: group2.minY + 0.49580 * group2.height))
        bezierPath.close()
        UIColor.white.setFill()
        bezierPath.fill()


        if (isPressed) {
            //// overlay 2 Drawing
            let overlay2Path = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
            orangeOverlay.setFill()
            overlay2Path.fill()
        }
    }

    public dynamic class func drawOrangeFilterButton(frame: CGRect = CGRect(x: 0, y: 0, width: 86, height: 85), isPressed: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let orangeOverlay = UIColor(red: 0.780, green: 0.404, blue: 0.090, alpha: 0.397)


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.03488 + 0.5), y: frame.minY + fastFloor(frame.height * 0.02353 + 0.5), width: fastFloor(frame.width * 0.96512 + 0.5) - fastFloor(frame.width * 0.03488 + 0.5), height: fastFloor(frame.height * 0.96471 + 0.5) - fastFloor(frame.height * 0.02353 + 0.5))


        //// Group 2
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
        HMAISStyleKit.mainOrangeColor.setFill()
        ovalPath.fill()


        //// Group
        if (isPressed) {
            //// overlay Drawing
            let overlayPath = UIBezierPath(ovalIn: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
            orangeOverlay.setFill()
            overlayPath.fill()
        }






        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX + fastFloor(frame.width * 0.30233 + 0.5), y: frame.minY + fastFloor(frame.height * 0.21176 + 0.5), width: fastFloor(frame.width * 0.79070 + 0.5) - fastFloor(frame.width * 0.30233 + 0.5), height: fastFloor(frame.height * 0.30588 + 0.5) - fastFloor(frame.height * 0.21176 + 0.5)), cornerRadius: 4)
        UIColor.white.setFill()
        rectanglePath.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: frame.minX + fastFloor(frame.width * 0.30233 + 0.5), y: frame.minY + fastFloor(frame.height * 0.37647 + 0.5), width: fastFloor(frame.width * 0.72093 + 0.5) - fastFloor(frame.width * 0.30233 + 0.5), height: fastFloor(frame.height * 0.47059 + 0.5) - fastFloor(frame.height * 0.37647 + 0.5)), cornerRadius: 4)
        UIColor.white.setFill()
        rectangle2Path.fill()


        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: frame.minX + fastFloor(frame.width * 0.30233 + 0.5), y: frame.minY + fastFloor(frame.height * 0.52941 + 0.5), width: fastFloor(frame.width * 0.65116 + 0.5) - fastFloor(frame.width * 0.30233 + 0.5), height: fastFloor(frame.height * 0.62353 + 0.5) - fastFloor(frame.height * 0.52941 + 0.5)), cornerRadius: 4)
        UIColor.white.setFill()
        rectangle3Path.fill()


        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(roundedRect: CGRect(x: frame.minX + fastFloor(frame.width * 0.30233 + 0.5), y: frame.minY + fastFloor(frame.height * 0.69412 + 0.5), width: fastFloor(frame.width * 0.60465 + 0.5) - fastFloor(frame.width * 0.30233 + 0.5), height: fastFloor(frame.height * 0.78824 + 0.5) - fastFloor(frame.height * 0.69412 + 0.5)), cornerRadius: 4)
        UIColor.white.setFill()
        rectangle4Path.fill()
    }

    public dynamic class func drawProgressIndicator(frame: CGRect = CGRect(x: 0, y: 0, width: 150, height: 150), progress: CGFloat = 0.906) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let progressIndicatorBGColor = UIColor(red: 0.323, green: 0.323, blue: 0.323, alpha: 1.000)

        //// Variable Declarations
        let resultAngle: CGFloat = -1 * progress * 360 + 90


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.11000) + 0.5, y: frame.minY + fastFloor(frame.height * 0.11000) + 0.5, width: fastFloor(frame.width * 0.89000) - fastFloor(frame.width * 0.11000), height: fastFloor(frame.height * 0.89000) - fastFloor(frame.height * 0.11000))


        //// Group
        //// bg Drawing
        let bgPath = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 1.00000 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5)))
        progressIndicatorBGColor.setStroke()
        bgPath.lineWidth = 7
        bgPath.stroke()


        //// fg Drawing
        let fgRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 1.00000 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
        let fgPath = UIBezierPath()
        fgPath.addArc(withCenter: CGPoint(x: fgRect.midX, y: fgRect.midY), radius: fgRect.width / 2, startAngle: -90 * CGFloat.pi/180, endAngle: -resultAngle * CGFloat.pi/180, clockwise: true)

        HMAISStyleKit.mainOrangeColor.setStroke()
        fgPath.lineWidth = 7
        fgPath.lineCapStyle = .round
        fgPath.stroke()
    }

}



extension UIColor {
    func withHue(_ newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func withSaturation(_ newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func withBrightness(_ newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func withAlpha(_ newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, brightness: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func highlight(withLevel highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func shadow(withLevel shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
}
